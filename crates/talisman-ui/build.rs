use std::env;
use std::fs;
use std::path::PathBuf;

use ttf_parser::{Face, OutlineBuilder};

#[derive(Clone, Copy, Debug)]
enum Op {
    M(f32, f32),
    L(f32, f32),
    Q(f32, f32, f32, f32),
    C(f32, f32, f32, f32, f32, f32),
    Z,
}

#[derive(Clone, Copy, Debug)]
struct Bounds {
    min_x: f32,
    min_y: f32,
    max_x: f32,
    max_y: f32,
    has_bounds: bool,
}

impl Bounds {
    fn new() -> Self {
        Self {
            min_x: 0.0,
            min_y: 0.0,
            max_x: 0.0,
            max_y: 0.0,
            has_bounds: false,
        }
    }

    fn update(&mut self, x: f32, y: f32) {
        if !self.has_bounds {
            self.min_x = x;
            self.max_x = x;
            self.min_y = y;
            self.max_y = y;
            self.has_bounds = true;
            return;
        }
        if x < self.min_x {
            self.min_x = x;
        }
        if x > self.max_x {
            self.max_x = x;
        }
        if y < self.min_y {
            self.min_y = y;
        }
        if y > self.max_y {
            self.max_y = y;
        }
    }
}

struct OutlineCollector {
    ops: Vec<Op>,
    bounds: Bounds,
    scale: f32,
    flip_y: bool,
}

impl OutlineCollector {
    fn new(scale: f32, flip_y: bool) -> Self {
        Self {
            ops: Vec::new(),
            bounds: Bounds::new(),
            scale,
            flip_y,
        }
    }

    fn norm(&self, x: f32, y: f32) -> (f32, f32) {
        let mut ny = y * self.scale;
        if self.flip_y {
            ny = -ny;
        }
        (x * self.scale, ny)
    }

    fn note(&mut self, x: f32, y: f32) {
        self.bounds.update(x, y);
    }
}

impl OutlineBuilder for OutlineCollector {
    fn move_to(&mut self, x: f32, y: f32) {
        let (nx, ny) = self.norm(x, y);
        self.ops.push(Op::M(nx, ny));
        self.note(nx, ny);
    }

    fn line_to(&mut self, x: f32, y: f32) {
        let (nx, ny) = self.norm(x, y);
        self.ops.push(Op::L(nx, ny));
        self.note(nx, ny);
    }

    fn quad_to(&mut self, x1: f32, y1: f32, x: f32, y: f32) {
        let (nx1, ny1) = self.norm(x1, y1);
        let (nx, ny) = self.norm(x, y);
        self.ops.push(Op::Q(nx1, ny1, nx, ny));
        self.note(nx1, ny1);
        self.note(nx, ny);
    }

    fn curve_to(&mut self, x1: f32, y1: f32, x2: f32, y2: f32, x: f32, y: f32) {
        let (nx1, ny1) = self.norm(x1, y1);
        let (nx2, ny2) = self.norm(x2, y2);
        let (nx, ny) = self.norm(x, y);
        self.ops.push(Op::C(nx1, ny1, nx2, ny2, nx, ny));
        self.note(nx1, ny1);
        self.note(nx2, ny2);
        self.note(nx, ny);
    }

    fn close(&mut self) {
        self.ops.push(Op::Z);
    }
}

fn fmt_f32(value: f32) -> String {
    let mut s = format!("{:.6}", value);
    if s == "-0.000000" {
        s = "0.0".to_string();
    }
    while s.contains('.') && s.ends_with('0') {
        s.pop();
    }
    if s.ends_with('.') {
        s.push('0');
    }
    if s == "-0" {
        s = "0.0".to_string();
    }
    s
}

fn generate_ascii_font(manifest_dir: &PathBuf, out_dir: &PathBuf, ttf_name: &str, mod_name: &str) {
    let font_path = manifest_dir.join(format!("../../assets/fonts/{}", ttf_name));
    println!("cargo:rerun-if-changed={}", font_path.display());

    let font_bytes = fs::read(&font_path).expect(&format!("Failed to read {}", ttf_name));
    let face = Face::parse(&font_bytes, 0).expect(&format!("Failed to parse {}", ttf_name));
    let units_per_em = face.units_per_em();
    let scale = 1.0 / units_per_em as f32;
    let flip_y = false; 

    let out_path = out_dir.join(format!("{}.rs", mod_name));
    let mut out = String::new();

    out.push_str("// @generated by build.rs - do not edit\n");
    out.push_str("use crate::{GlyphOp, GlyphBounds, GlyphMetrics};\n\n");

    for c in 0x20u8..=0x7E {
        let ch = c as char;
        let glyph_id = match face.glyph_index(ch) {
            Some(id) => id,
            None => continue,
        };

        let mut collector = OutlineCollector::new(scale, flip_y);
        let has_outline = face.outline_glyph(glyph_id, &mut collector).is_some();
        if !has_outline {
            collector.ops.clear();
        }

        out.push_str(&format!("pub const GLYPH_{:02X}_OPS: &[GlyphOp] = &[\n", c));
        for op in &collector.ops {
             match *op {
                Op::M(x, y) => out.push_str(&format!("    GlyphOp::M({}, {}),\n", fmt_f32(x), fmt_f32(y))),
                Op::L(x, y) => out.push_str(&format!("    GlyphOp::L({}, {}),\n", fmt_f32(x), fmt_f32(y))),
                Op::Q(x1, y1, x, y) => out.push_str(&format!("    GlyphOp::Q({}, {}, {}, {}),\n", fmt_f32(x1), fmt_f32(y1), fmt_f32(x), fmt_f32(y))),
                Op::C(x1, y1, x2, y2, x, y) => out.push_str(&format!("    GlyphOp::C({}, {}, {}, {}, {}, {}),\n", fmt_f32(x1), fmt_f32(y1), fmt_f32(x2), fmt_f32(y2), fmt_f32(x), fmt_f32(y))),
                Op::Z => out.push_str("    GlyphOp::Z,\n"),
            }
        }
        out.push_str("];\n");

        let bounds = collector.bounds;
        let (min_x, min_y, max_x, max_y) = if bounds.has_bounds {
            (bounds.min_x, bounds.min_y, bounds.max_x, bounds.max_y)
        } else {
            (0.0, 0.0, 0.0, 0.0)
        };

        let advance = face.glyph_hor_advance(glyph_id).unwrap_or(0);
        let lsb = face.glyph_hor_side_bearing(glyph_id).unwrap_or(0);
        let norm_advance = advance as f32 * scale;
        let norm_lsb = lsb as f32 * scale;

        out.push_str(&format!(
            "pub const GLYPH_{:02X}_BOUNDS: GlyphBounds = GlyphBounds {{ min_x: {}, min_y: {}, max_x: {}, max_y: {} }};\n",
            c, fmt_f32(min_x), fmt_f32(min_y), fmt_f32(max_x), fmt_f32(max_y)
        ));
        
        out.push_str(&format!(
            "pub const GLYPH_{:02X}_METRICS: GlyphMetrics = GlyphMetrics {{ advance_width: {}, left_side_bearing: {} }};\n\n",
            c, fmt_f32(norm_advance), fmt_f32(norm_lsb)
        ));
    }

    // Match arms for ops
    out.push_str("pub fn ops_for_ascii(c: char) -> Option<&'static [GlyphOp]> {\n");
    out.push_str("    match c {\n");
    for c in 0x20u8..=0x7E {
        out.push_str(&format!("        {:?} => Some(GLYPH_{:02X}_OPS),\n", c as char, c));
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Match arms for bounds
    out.push_str("pub fn bounds_for_ascii(c: char) -> Option<GlyphBounds> {\n");
    out.push_str("    match c {\n");
    for c in 0x20u8..=0x7E {
         out.push_str(&format!("        {:?} => Some(GLYPH_{:02X}_BOUNDS),\n", c as char, c));
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n\n");

    // Match arms for metrics
    out.push_str("pub fn metrics_for_ascii(c: char) -> Option<GlyphMetrics> {\n");
    out.push_str("    match c {\n");
    for c in 0x20u8..=0x7E {
         out.push_str(&format!("        {:?} => Some(GLYPH_{:02X}_METRICS),\n", c as char, c));
    }
    out.push_str("        _ => None,\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(&out_path, out).expect(&format!("Failed to write {}.rs", mod_name));
}

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    generate_ascii_font(&manifest_dir, &out_dir, "IBMPlexSans-Regular.ttf", "plex_sans_regular_ops");
    generate_ascii_font(&manifest_dir, &out_dir, "IBMPlexSans-Bold.ttf", "plex_sans_bold_ops");
    generate_ascii_font(&manifest_dir, &out_dir, "IBMPlexMono-Regular.ttf", "plex_mono_regular_ops");
    generate_ascii_font(&manifest_dir, &out_dir, "IBMPlexMono-Medium.ttf", "plex_mono_medium_ops");
}
